# -*- coding: utf-8 -*-
"""Model_Proj_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vjMeCEzYMzjJ2hl1uAWlvys8LbfvjDO8
"""

import pickle
import tensorflow as tf
import numpy as np
from numpy import random
#import tensorflow.keras as keras
import heapq
import math

from copy import deepcopy
tf.config.run_functions_eagerly(True)

!pip install visualkeras

import visualkeras

import time

from google.colab import drive
drive.mount('/content/drive')

"""# New Section"""

grids = pickle.load(open('drive/MyDrive/grids.pkl','rb'))
infer_grids = pickle.load(open('drive/MyDrive/infer_grids.pkl','rb'))
positions = pickle.load(open('positions.pkl','rb'))

outputs = pickle.load(open('actions.pkl','rb'))

positions

print(len(grids), len(infer_grids), len(positions), len(outputs))

dim = 7
train_out = tf.keras.utils.to_categorical(outputs, num_classes=4)

train_out[0]

dim=7
grid = tf.keras.Input(shape=(dim,dim))
grid2 = tf.keras.Input(shape=(dim, dim))
position = tf.keras.Input(shape=(1*2,))

# convoluted = tf.keras.layers.Conv2D(32, (3, 3), activation="relu")(grid)
# max_p = tf.keras.layers.MaxPooling2D((3, 3))(convoluted)
a = tf.keras.layers.Flatten()(grid)
b = tf.keras.layers.Flatten()(grid2)
# out = tf.keras.layers.Dense(256, activation='relu')(a)

concat = tf.keras.layers.concatenate([a, b, position])

out1 = tf.keras.layers.Dense(128, activation='relu')(concat)
out2 = tf.keras.layers.Dense(32, activation='relu')(out1)

final_out = tf.keras.layers.Dense(4, activation='softmax')(out2)

model = tf.keras.Model(inputs= [grid, grid2, position], outputs = final_out)

from tensorflow.python.keras.models import Sequential
from tensorflow.python.keras.layers import Dense, Flatten, Conv2D, Dropout, MaxPooling2D, InputLayer, ZeroPadding2D, Concatenate
from collections import defaultdict

m1 = Sequential()
l1=m1.add(InputLayer(input_shape=(7,7,1)))
m1.add(Flatten())
l2=m1.add(InputLayer(1,2,1))

m1.add(Dense(256, activation = 'relu'))
m1.add(Dropout(0.2))
m1.add(Dense(64, activation = 'relu'))
m1.add(Dropout(0.2))
m1.add(Dense(32, activation = 'relu'))
m1.add(Dropout(0.2))
m1.add(Dense(4, activation = 'softmax'))

color_map = defaultdict(dict)

color_map[Dropout]['fill'] = 'pink'
color_map[Dense]['fill'] = 'green'
color_map[Flatten]['fill'] = 'teal'

visualkeras.layered_view(m1).show()

model.summary()

model.compile(optimizer='adam',loss = 'categorical_crossentropy', metrics=['accuracy'])

import numpy as np
input_l1 = np.array(grids)
input_l1.reshape((input_l1.shape[0], input_l1.shape[1], input_l1.shape[2]))

input_l2 = np.array(positions)
input_l2.shape

input_l3 = np.array(infer_grids)
input_l3.reshape((input_l3.shape[0], input_l3.shape[1], input_l3.shape[2]))

input_l3.shape

model.fit([input_l1, input_l3, input_l2], train_out, epochs=5, validation_split=0.2, batch_size=128)

model.save("model_50dim_local_035_project2.h5")

model = tf.keras.models.load_model("model_50dim_local_035_project2.h5")

class Grid(object):
    def __init__(self, dim: int, probability: float):
        self.dim = dim
        self.probability = probability
        self._grid, self._blocked_cells = self._generate_grid(dim, probability)

    def _generate_grid(self, dim: int, probability: float):
        cell_probabilities = self.generate_probabilities(dim * dim)
        grid = np.ndarray(shape=(dim, dim), dtype=int)
        blocked_cells = []
        for i, cell_probability in enumerate(cell_probabilities):
            if cell_probability < probability:
                grid[i//dim, i % dim] = 0
                blocked_cells.append((i//dim, i % dim))
            else:
                grid[i//dim, i % dim] = 1
        grid[0, 0] = 1
        grid[dim-1, dim-1] = 1
        return grid, blocked_cells

    def is_blocked(self, cell: tuple):
        return True if self._grid[cell[0], cell[1]] == 0 else False

    def get_grid(self):
        # return np.full((self.dim, self.dim), 2)
        return np.ones(shape=(self.dim, self.dim), dtype=int)

    def get_full_grid(self):
        return self._grid

    def get_children(self, cell):
        children = []
        for diff in [+1, -1]:
            if 0 < cell[0] + diff < self.dim:
                children.append((cell[0]+diff, cell[1]))
            if 0 < cell[1] + diff < self.dim:
                children.append((cell[0], cell[1]+diff))
        return children
    
    def get_all_neighbors_blocks(self, cell):
        movement = [(-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1), (-1, 0)]
        neighbors = []
        blocked_cells = 0
        for move_x, move_y in movement:
            if 0 <= cell[0] + move_x < self.dim and 0 <= cell[1] + move_y < self.dim:
                neighbors.append((cell[0] + move_x, cell[1] + move_y))
                if self.is_blocked((cell[0] + move_x, cell[1] + move_y)):
                    blocked_cells += 1

        return neighbors, blocked_cells

    @staticmethod
    def generate_probabilities(count: int):
        return random.uniform(0.0, 1, count)

def get_prediction(grid, infer_grid, pos):
  grid_copy = np.pad(grid, 3, "constant", constant_values=-1)
  local_grid = np.array([grid_copy[pos[0]:pos[0]+2*3+1, pos[1]:pos[1]+2*3+1]])
  infer_grid_copy = np.pad(infer_grid, 3, "constant", constant_values=-1)
  infer_local_grid = np.array([infer_grid_copy[pos[0]:pos[0]+2*3+1, pos[1]:pos[1]+2*3+1]])
  # local_grid.reshape(1, local_grid.shape[0], local_grid.shape[1])
  pos = np.array([pos])
  pos.reshape(1, pos.shape[0], pos.shape[1])
  pred = model.predict([local_grid, infer_local_grid, pos])
  return pred.argmax()

class RepeatedAStar(object):
    def __init__(self, grid: Grid, local_layers: int):
        self.local_layers = local_layers
        self.grid = grid
        self.dim = self.grid.dim
        self.discovered_grid = self.grid.get_grid()
        self.training_grid = self.grid.get_grid()
        self.infer_grid = np.full((self.dim, self.dim), -1, dtype=int)
        self.discovered_cells = set()
        self.processed_nodes_count = 0
        self.repeated_a_star_path = []
        self.discovered_grid_path = []
        self.grids = []
        self.no_infer_grids = []
        self.actions = []
        self.positions = []
        self.infer_grids = []

    def check_neighbors(self, node):
        for neighbor in self.grid.get_children(node):
            if self.grid.is_blocked(neighbor):
                self.discovered_grid[neighbor[0], neighbor[1]] = 0
            else:
                self.discovered_grid[neighbor[0], neighbor[1]] = 1
            self.discovered_cells.add(neighbor)

    @staticmethod
    def heuristic_estimate(node1, node2, heuristic_type="manhattan"):
        # if heuristic_type == "euclidean":
        #     return math.sqrt(pow(node2[0] - node1[0], 2) + pow(node2[1] - node1[1], 2))
        # elif heuristic_type == "chebyshev":
        #     return max(abs(node1[0] - node2[0]), abs(node1[1] - node2[1]))
        # elif heuristic_type == "modified_1":
        #     return 2*math.sqrt(pow(node2[0] - node1[0], 2) + pow(node2[1] - node1[1], 2)) + 3 * (abs(node1[0] - node2[0]) + abs(node1[1] - node2[1]))
        # elif "modified_" in heuristic_type:
        #     weight = float(heuristic_type.split("_")[1])
        #     return weight * (abs(node1[0] - node2[0]) + abs(node1[1] - node2[1]))
        return abs(node1[0] - node2[0]) + abs(node1[1] - node2[1])

    def a_star_search(self, start, goal, grid, heuristic_type="manhattan", weight=1):

        priority_queue = []
        actual_cost = {}
        parent = {}

        heapq.heappush(priority_queue, (0, start))
        parent[start] = None
        actual_cost[start] = 0
        current_node = None

        while priority_queue:
            current_node = heapq.heappop(priority_queue)[1]
            self.processed_nodes_count += 1

            if current_node == goal:
                break

            for child in self.grid.get_children(current_node):
                if grid[child[0], child[1]] != 0:
                    if child not in actual_cost or actual_cost[child] > actual_cost[current_node] + 1:
                        heuristic = self.heuristic_estimate(child, goal, heuristic_type)
                        heapq.heappush(priority_queue, (actual_cost[current_node] + 1 + weight*heuristic, child))
                        actual_cost[child] = actual_cost[current_node] + 1
                        parent[child] = current_node

        if current_node == goal:
            path = []
            while parent[current_node] is not None:
                path.insert(0, current_node)
                current_node = parent[current_node]
            path.insert(0, start)
            return path
        return []

    def execute_repeated_a_star(self, heuristic_type="manhattan", weight=1):
        path_found = []
        start = (0, 0)
        goal = (self.dim - 1, self.dim - 1)

        while True:
            path_to_goal = self.a_star_search(start, goal, self.discovered_grid, heuristic_type, weight)
            if not path_to_goal:
                break
            for node_no, node in enumerate(path_to_goal):
                self.discovered_cells.add(node)
                self.check_neighbors(node)
                if node == goal or not self.grid.is_blocked(path_to_goal[node_no+1]):
                    self.discovered_grid[node[0], node[1]] = 1
                    path_found.append(node)
                else:
                    self.discovered_cells.add(path_to_goal[node_no+1])
                    self.discovered_grid[path_to_goal[node_no+1][0], path_to_goal[node_no+1][1]] = 0
                    start = node
                    break
                if node != goal:
                    grid_copy = np.pad(self.discovered_grid, self.local_layers, "constant", constant_values=-1)
                    local_grid = grid_copy[node[0]:node[0]+2*self.local_layers+1, node[1]:node[1]+2*self.local_layers+1]
                    self.grids.append(local_grid)
                    self.positions.append(node)
                    move_x = path_to_goal[node_no+1][0] - node[0]
                    move_y = path_to_goal[node_no+1][1] - node[1]
                    if move_x == -1:
                        self.actions.append(0)
                    elif move_x == 1:
                        self.actions.append(1)
                    elif move_y == -1:
                        self.actions.append(2)
                    elif move_y == 1:
                        self.actions.append(3)

            if path_found and path_found[-1] == goal:
                break

        if path_found and path_found[-1] == goal:
            self.repeated_a_star_path = path_found
            return path_found
        return []

    def execute_repeated_a_star_infer(self, heuristic_type="manhattan", weight=1, blind=False, sense=False, advance=False):
        path_found = []
        self.bumped_into_block = 0
        self.processed_nodes_count = 0
        self.planning_time = 0
        start = (0, 0)
        goal = (self.dim - 1, self.dim - 1)

        while True:

            start_time = time.monotonic()
            path_to_goal = self.a_star_search(start, goal, self.discovered_grid, heuristic_type, weight)
            self.planning_time += time.monotonic() - start_time
            if not path_to_goal:
                break

            for node_no, node in enumerate(path_to_goal):
                self.discovered_cells.add(node)
                if not blind:
                    self.check_neighbors(node)
                if node == goal or not self.grid.is_blocked(node):
                    path_found.append(node)
                    if sense:
                        if not advance:
                            self.infer_surroundings(node, path_found[:-1])
                        else:
                            self.infer_surroundings2(node, path_found[:-1])
                        if [path_node for path_node in path_found if
                            path_node in self.discovered_cells and self.discovered_grid[path_node[0],
                                                                                        path_node[1]] == 0]:
                            print("Block found in path")
                            print([path_node for path_node in path_found if
                                   path_node in self.discovered_cells and self.discovered_grid[path_node[0],
                                                                                               path_node[
                                                                                                   1]] == 0])
                            # import pickle

                            # with open("grid.pkl", "wb") as f:
                            #     pickle.dump(self.grid.get_full_grid(), f)
                            path_found.pop()
                            start = node
                            break
                else:
                    # print(f"Bumped into block {node}")
                    self.bumped_into_block += 1
                    self.discovered_grid[node[0], node[1]] = 0
                    self.training_grid[node[0], node[1]] = 0
                    start = path_found[-1]
                    path_found.pop()
                    break
                if node != goal and not self.grid.is_blocked(path_to_goal[node_no+1]):
                    grid_copy = np.pad(self.discovered_grid, self.local_layers, "constant", constant_values=-1)
                    local_grid = grid_copy[node[0]:node[0] + 2 * self.local_layers + 1,
                                 node[1]:node[1] + 2 * self.local_layers + 1]
                    self.grids.append(local_grid)
                    grid_copy = np.pad(self.training_grid, self.local_layers, "constant", constant_values=-1)
                    local_grid = grid_copy[node[0]:node[0]+2*self.local_layers+1, node[1]:node[1]+2*self.local_layers+1]
                    self.no_infer_grids.append(local_grid)
                    grid_copy = np.pad(self.infer_grid, self.local_layers, "constant", constant_values=-1)
                    local_grid = grid_copy[node[0]:node[0] + 2 * self.local_layers + 1, node[1]:node[1] + 2 * self.local_layers + 1]
                    self.infer_grids.append(local_grid)
                    self.positions.append(node)
                    move_x = path_to_goal[node_no+1][0] - node[0]
                    move_y = path_to_goal[node_no+1][1] - node[1]
                    if move_x == -1:
                        self.actions.append(0)
                    elif move_x == 1:
                        self.actions.append(1)
                    elif move_y == -1:
                        self.actions.append(2)
                    elif move_y == 1:
                        self.actions.append(3)

            if path_found and path_found[-1] == goal:
                break

        if path_found and path_found[-1] == goal:
            self.repeated_a_star_path = path_found
            return path_found
        return []

    def infer_surroundings(self, current, path_taken, level=0):

        neighbors, blocked_cells_count = self.grid.get_all_neighbors_blocks(current)
        if self.infer_grid[current[0], current[1]] == -1:
            self.infer_grid[current[0], current[1]] = blocked_cells_count
        confirm_blocked = len([neighbor for neighbor in neighbors if
                               neighbor in self.discovered_cells and self.discovered_grid[
                                   neighbor[0], neighbor[1]] == 0])
        confirmed_empty = len([neighbor for neighbor in neighbors if
                               neighbor in self.discovered_cells and self.discovered_grid[
                                   neighbor[0], neighbor[1]] != 0])
        unconfirmed_cells = len([neighbor for neighbor in neighbors if neighbor not in self.discovered_cells])
        if unconfirmed_cells > 0:
            if blocked_cells_count == confirm_blocked:
                for neighbor in neighbors:
                    if neighbor not in self.discovered_cells:
                        self.discovered_cells.add(neighbor)
            elif len(neighbors) - blocked_cells_count == confirmed_empty:
                for neighbor in neighbors:
                    if neighbor not in self.discovered_cells:
                        self.discovered_grid[neighbor[0], neighbor[1]] = 0
                        self.discovered_cells.add(neighbor)

        unconfirmed_cells = len([neighbor for neighbor in neighbors if neighbor not in self.discovered_cells])

        if unconfirmed_cells == 0 or level == 0:
            if path_taken and level < 20:
                self.infer_surroundings(path_taken[-1], path_taken[:-1], level + 1)

    def find_start_node(self, path, node):
        path_set = set(path)
        total_paths = len(path) - 1
        current_neigbors = self.grid.get_children(node)
        open_neighbors = [neighbor for neighbor in current_neigbors if
                          not self.grid.is_blocked(neighbor) and neighbor not in path_set]
        if open_neighbors:
            return -1, node

        while total_paths >= 0:
            neighbors = self.grid.get_children(path[total_paths])
            open_neighbors = [neighbor for neighbor in neighbors if
                              not self.grid.is_blocked(neighbor) and neighbor not in path_set]
            if open_neighbors:
                return total_paths, path[total_paths]
            total_paths -= 1

        return -1, node

    def execute_repeated_a_star_diff_start(self):
        path_found = []
        start = (0, 0)
        goal = (self.dim - 1, self.dim - 1)

        while True:
            path_to_goal = self.a_star_search(start, goal, self.discovered_grid)
            if not path_to_goal:
                break
            for node_no, node in enumerate(path_to_goal):
                self.discovered_cells.add(node)
                self.check_neighbors(node)
                if node == goal or not self.grid.is_blocked(path_to_goal[node_no + 1]):
                    path_found.append(node)
                else:
                    start_node_no, start = self.find_start_node(path_found, node)
                    if start_node_no != -1:
                        path_found.extend(path_found[-1:start_node_no:-1])
                        path_found.append(node)
                    break
            if path_found and path_found[-1] == goal:
                break

        if path_found and path_found[-1] == goal:
            self.repeated_a_star_path = path_found
            return path_found
        return []

    def a_star_discovered_grid_world(self):
        for row_no in range(self.dim):
            for col_no in range(self.dim):
                if (row_no, col_no) not in self.discovered_cells:
                    self.discovered_grid[row_no, col_no] = 0

        path_to_goal = self.a_star_search((0, 0), (self.dim-1, self.dim-1), self.discovered_grid)
        self.discovered_grid_path = path_to_goal
        return path_to_goal

    def a_star_full_grid_world(self, heuristic_type="manhattan"):
        path_to_goal = self.a_star_search((0, 0), (self.dim-1, self.dim-1), self.grid.get_full_grid(), heuristic_type)
        return path_to_goal

j = 10
success = 0
while j > 0:
  while True:
    dim = 50
    prob = 0.3
    grid = Grid(dim, prob)
    rep = RepeatedAStar(grid, 3)
    path = rep.a_star_full_grid_world(grid.get_full_grid)
    if path:
      break
  avgpath = rep.execute_repeated_a_star_infer(blind=True, sense=True)
  knowledge_grid = grid.get_grid()
  infer_grid = np.full((dim, dim), -1)
  start = (0,0)
  i = 300
  move_map = {
      0: (-1, 0),
      1: (1, 0),
      2: (0, -1),
      3: (0, 1)
  }
  path = []
  preds = []
  _, blocked_nodes = grid.get_all_neighbors_blocks(start)
  infer_grid[start[0], start[1]] = blocked_nodes
  while start != (dim-1, dim-1) and i > 0:
    move = get_prediction(knowledge_grid, infer_grid, start)
    move_row, move_col = move_map[move]
    new_pos = (start[0]+move_row, start[1]+move_col)
    if 0 <= new_pos[0] < dim and 0 <= new_pos[1] < dim:
      preds.append(new_pos)
      if not grid.is_blocked(new_pos):
        knowledge_grid[new_pos[0], new_pos[1]] = 1
        _, blocked_nodes = grid.get_all_neighbors_blocks(new_pos)
        infer_grid[new_pos[0], new_pos[1]] = blocked_nodes
        start = new_pos
        path.append(start)
      else:
        knowledge_grid[new_pos[0], new_pos[1]] = 0
    i -= 1

  print(f"{len(avgpath)} --> {len(path)}")
  if start == (dim-1, dim-1):
    success += 1
    print("success")
  else:
    print("fail")
  
  
  j -= 1
print(success)
print(success/10)





